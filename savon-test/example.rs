use savon :: internal :: xmltree ; use savon :: rpser :: xml :: * ; # [derive (Clone , Debug , Default)] pub struct FullCountryInfoAllCountriesResponse { pub full_country_info_all_countries_result : ArrayOftCountryInfo , } impl savon :: gen :: ToElements for FullCountryInfoAllCountriesResponse { fn to_elements (& self) -> Vec < xmltree :: Element > { vec ! [vec ! [xmltree :: Element :: node ("FullCountryInfoAllCountriesResult") . with_children (self . full_country_info_all_countries_result . to_elements ())]] . drain (..) . flatten () . collect () } } impl savon :: gen :: FromElement for FullCountryInfoAllCountriesResponse { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { Ok (FullCountryInfoAllCountriesResponse { full_country_info_all_countries_result : element . get_at_path (& ["FullCountryInfoAllCountriesResult"]) . map_err (savon :: Error :: from) . and_then (| e | ArrayOftCountryInfo :: from_element (& e) . map_err (savon :: Error :: from)) ? , }) } } # [derive (Clone , Debug , Default)] pub struct ArrayOftCountryCodeAndName { pub t_country_code_and_name : Option < Vec < TCountryCodeAndName > > , } impl savon :: gen :: ToElements for ArrayOftCountryCodeAndName { fn to_elements (& self) -> Vec < xmltree :: Element > { vec ! [self . t_country_code_and_name . as_ref () . map (| v | v . iter () . map (| i | { xmltree :: Element :: node ("tCountryCodeAndName") . with_children (i . to_elements ()) }) . collect ()) . unwrap_or_else (Vec :: new)] . drain (..) . flatten () . collect () } } impl savon :: gen :: FromElement for ArrayOftCountryCodeAndName { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { Ok (ArrayOftCountryCodeAndName { t_country_code_and_name : Some ({ let mut v = vec ! [] ; for elem in element . children . iter () . filter_map (| c | c . as_element ()) { v . push (TCountryCodeAndName :: from_element (& elem) ?) ; } v } ,) }) } } # [derive (Clone , Debug , Default)] pub struct LanguageISOCodeResponse { pub language_i_s_o_code_result : String , } impl savon :: gen :: ToElements for LanguageISOCodeResponse { fn to_elements (& self) -> Vec < xmltree :: Element > { vec ! [vec ! [xmltree :: Element :: node ("LanguageISOCodeResult") . with_text (self . language_i_s_o_code_result . to_string ())]] . drain (..) . flatten () . collect () } } impl savon :: gen :: FromElement for LanguageISOCodeResponse { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { Ok (LanguageISOCodeResponse { language_i_s_o_code_result : element . get_at_path (& ["LanguageISOCodeResult"]) . and_then (| e | e . get_text () . map (| s | s . to_string ()) . ok_or (savon :: rpser :: xml :: Error :: Empty)) ? , }) } } # [derive (Clone , Debug , Default)] pub struct CountryISOCode { pub s_country_name : String , } impl savon :: gen :: ToElements for CountryISOCode { fn to_elements (& self) -> Vec < xmltree :: Element > { vec ! [vec ! [xmltree :: Element :: node ("sCountryName") . with_text (self . s_country_name . to_string ())]] . drain (..) . flatten () . collect () } } impl savon :: gen :: FromElement for CountryISOCode { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { Ok (CountryISOCode { s_country_name : element . get_at_path (& ["sCountryName"]) . and_then (| e | e . get_text () . map (| s | s . to_string ()) . ok_or (savon :: rpser :: xml :: Error :: Empty)) ? , }) } } # [derive (Clone , Debug , Default)] pub struct CountryName { pub s_country_i_s_o_code : String , } impl savon :: gen :: ToElements for CountryName { fn to_elements (& self) -> Vec < xmltree :: Element > { vec ! [vec ! [xmltree :: Element :: node ("sCountryISOCode") . with_text (self . s_country_i_s_o_code . to_string ())]] . drain (..) . flatten () . collect () } } impl savon :: gen :: FromElement for CountryName { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { Ok (CountryName { s_country_i_s_o_code : element . get_at_path (& ["sCountryISOCode"]) . and_then (| e | e . get_text () . map (| s | s . to_string ()) . ok_or (savon :: rpser :: xml :: Error :: Empty)) ? , }) } } # [derive (Clone , Debug , Default)] pub struct LanguageName { pub s_i_s_o_code : String , } impl savon :: gen :: ToElements for LanguageName { fn to_elements (& self) -> Vec < xmltree :: Element > { vec ! [vec ! [xmltree :: Element :: node ("sISOCode") . with_text (self . s_i_s_o_code . to_string ())]] . drain (..) . flatten () . collect () } } impl savon :: gen :: FromElement for LanguageName { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { Ok (LanguageName { s_i_s_o_code : element . get_at_path (& ["sISOCode"]) . and_then (| e | e . get_text () . map (| s | s . to_string ()) . ok_or (savon :: rpser :: xml :: Error :: Empty)) ? , }) } } # [derive (Clone , Debug , Default)] pub struct ListOfCurrenciesByNameResponse { pub list_of_currencies_by_name_result : ArrayOftCurrency , } impl savon :: gen :: ToElements for ListOfCurrenciesByNameResponse { fn to_elements (& self) -> Vec < xmltree :: Element > { vec ! [vec ! [xmltree :: Element :: node ("ListOfCurrenciesByNameResult") . with_children (self . list_of_currencies_by_name_result . to_elements ())]] . drain (..) . flatten () . collect () } } impl savon :: gen :: FromElement for ListOfCurrenciesByNameResponse { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { Ok (ListOfCurrenciesByNameResponse { list_of_currencies_by_name_result : element . get_at_path (& ["ListOfCurrenciesByNameResult"]) . map_err (savon :: Error :: from) . and_then (| e | ArrayOftCurrency :: from_element (& e) . map_err (savon :: Error :: from)) ? , }) } } # [derive (Clone , Debug , Default)] pub struct ListOfCurrenciesByCodeResponse { pub list_of_currencies_by_code_result : ArrayOftCurrency , } impl savon :: gen :: ToElements for ListOfCurrenciesByCodeResponse { fn to_elements (& self) -> Vec < xmltree :: Element > { vec ! [vec ! [xmltree :: Element :: node ("ListOfCurrenciesByCodeResult") . with_children (self . list_of_currencies_by_code_result . to_elements ())]] . drain (..) . flatten () . collect () } } impl savon :: gen :: FromElement for ListOfCurrenciesByCodeResponse { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { Ok (ListOfCurrenciesByCodeResponse { list_of_currencies_by_code_result : element . get_at_path (& ["ListOfCurrenciesByCodeResult"]) . map_err (savon :: Error :: from) . and_then (| e | ArrayOftCurrency :: from_element (& e) . map_err (savon :: Error :: from)) ? , }) } } # [derive (Clone , Debug , Default)] pub struct TCurrency { pub s_i_s_o_code : String , pub s_name : String , } impl savon :: gen :: ToElements for TCurrency { fn to_elements (& self) -> Vec < xmltree :: Element > { vec ! [vec ! [xmltree :: Element :: node ("sISOCode") . with_text (self . s_i_s_o_code . to_string ())] , vec ! [xmltree :: Element :: node ("sName") . with_text (self . s_name . to_string ())]] . drain (..) . flatten () . collect () } } impl savon :: gen :: FromElement for TCurrency { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { Ok (TCurrency { s_i_s_o_code : element . get_at_path (& ["sISOCode"]) . and_then (| e | e . get_text () . map (| s | s . to_string ()) . ok_or (savon :: rpser :: xml :: Error :: Empty)) ? , s_name : element . get_at_path (& ["sName"]) . and_then (| e | e . get_text () . map (| s | s . to_string ()) . ok_or (savon :: rpser :: xml :: Error :: Empty)) ? , }) } } # [derive (Clone , Debug , Default)] pub struct TCountryInfo { pub s_continent_code : String , pub s_i_s_o_code : String , pub s_currency_i_s_o_code : String , pub s_phone_code : String , pub languages : ArrayOftLanguage , pub s_country_flag : String , pub s_capital_city : String , pub s_name : String , } impl savon :: gen :: ToElements for TCountryInfo { fn to_elements (& self) -> Vec < xmltree :: Element > { vec ! [vec ! [xmltree :: Element :: node ("sContinentCode") . with_text (self . s_continent_code . to_string ())] , vec ! [xmltree :: Element :: node ("sISOCode") . with_text (self . s_i_s_o_code . to_string ())] , vec ! [xmltree :: Element :: node ("sCurrencyISOCode") . with_text (self . s_currency_i_s_o_code . to_string ())] , vec ! [xmltree :: Element :: node ("sPhoneCode") . with_text (self . s_phone_code . to_string ())] , vec ! [xmltree :: Element :: node ("Languages") . with_children (self . languages . to_elements ())] , vec ! [xmltree :: Element :: node ("sCountryFlag") . with_text (self . s_country_flag . to_string ())] , vec ! [xmltree :: Element :: node ("sCapitalCity") . with_text (self . s_capital_city . to_string ())] , vec ! [xmltree :: Element :: node ("sName") . with_text (self . s_name . to_string ())]] . drain (..) . flatten () . collect () } } impl savon :: gen :: FromElement for TCountryInfo { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { Ok (TCountryInfo { s_continent_code : element . get_at_path (& ["sContinentCode"]) . and_then (| e | e . get_text () . map (| s | s . to_string ()) . ok_or (savon :: rpser :: xml :: Error :: Empty)) ? , s_i_s_o_code : element . get_at_path (& ["sISOCode"]) . and_then (| e | e . get_text () . map (| s | s . to_string ()) . ok_or (savon :: rpser :: xml :: Error :: Empty)) ? , s_currency_i_s_o_code : element . get_at_path (& ["sCurrencyISOCode"]) . and_then (| e | e . get_text () . map (| s | s . to_string ()) . ok_or (savon :: rpser :: xml :: Error :: Empty)) ? , s_phone_code : element . get_at_path (& ["sPhoneCode"]) . and_then (| e | e . get_text () . map (| s | s . to_string ()) . ok_or (savon :: rpser :: xml :: Error :: Empty)) ? , languages : element . get_at_path (& ["Languages"]) . map_err (savon :: Error :: from) . and_then (| e | ArrayOftLanguage :: from_element (& e) . map_err (savon :: Error :: from)) ? , s_country_flag : element . get_at_path (& ["sCountryFlag"]) . and_then (| e | e . get_text () . map (| s | s . to_string ()) . ok_or (savon :: rpser :: xml :: Error :: Empty)) ? , s_capital_city : element . get_at_path (& ["sCapitalCity"]) . and_then (| e | e . get_text () . map (| s | s . to_string ()) . ok_or (savon :: rpser :: xml :: Error :: Empty)) ? , s_name : element . get_at_path (& ["sName"]) . and_then (| e | e . get_text () . map (| s | s . to_string ()) . ok_or (savon :: rpser :: xml :: Error :: Empty)) ? , }) } } # [derive (Clone , Debug , Default)] pub struct ListOfContinentsByName { } impl savon :: gen :: ToElements for ListOfContinentsByName { fn to_elements (& self) -> Vec < xmltree :: Element > { vec ! [] } } impl savon :: gen :: FromElement for ListOfContinentsByName { fn from_element (_element : & xmltree :: Element) -> Result < Self , savon :: Error > { Ok (ListOfContinentsByName { }) } } # [derive (Clone , Debug , Default)] pub struct TCountryCodeAndName { pub s_name : String , pub s_i_s_o_code : String , } impl savon :: gen :: ToElements for TCountryCodeAndName { fn to_elements (& self) -> Vec < xmltree :: Element > { vec ! [vec ! [xmltree :: Element :: node ("sName") . with_text (self . s_name . to_string ())] , vec ! [xmltree :: Element :: node ("sISOCode") . with_text (self . s_i_s_o_code . to_string ())]] . drain (..) . flatten () . collect () } } impl savon :: gen :: FromElement for TCountryCodeAndName { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { Ok (TCountryCodeAndName { s_name : element . get_at_path (& ["sName"]) . and_then (| e | e . get_text () . map (| s | s . to_string ()) . ok_or (savon :: rpser :: xml :: Error :: Empty)) ? , s_i_s_o_code : element . get_at_path (& ["sISOCode"]) . and_then (| e | e . get_text () . map (| s | s . to_string ()) . ok_or (savon :: rpser :: xml :: Error :: Empty)) ? , }) } } # [derive (Clone , Debug , Default)] pub struct FullCountryInfoAllCountries { } impl savon :: gen :: ToElements for FullCountryInfoAllCountries { fn to_elements (& self) -> Vec < xmltree :: Element > { vec ! [] } } impl savon :: gen :: FromElement for FullCountryInfoAllCountries { fn from_element (_element : & xmltree :: Element) -> Result < Self , savon :: Error > { Ok (FullCountryInfoAllCountries { }) } } # [derive (Clone , Debug , Default)] pub struct ListOfLanguagesByName { } impl savon :: gen :: ToElements for ListOfLanguagesByName { fn to_elements (& self) -> Vec < xmltree :: Element > { vec ! [] } } impl savon :: gen :: FromElement for ListOfLanguagesByName { fn from_element (_element : & xmltree :: Element) -> Result < Self , savon :: Error > { Ok (ListOfLanguagesByName { }) } } # [derive (Clone , Debug , Default)] pub struct TLanguage { pub s_i_s_o_code : String , pub s_name : String , } impl savon :: gen :: ToElements for TLanguage { fn to_elements (& self) -> Vec < xmltree :: Element > { vec ! [vec ! [xmltree :: Element :: node ("sISOCode") . with_text (self . s_i_s_o_code . to_string ())] , vec ! [xmltree :: Element :: node ("sName") . with_text (self . s_name . to_string ())]] . drain (..) . flatten () . collect () } } impl savon :: gen :: FromElement for TLanguage { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { Ok (TLanguage { s_i_s_o_code : element . get_at_path (& ["sISOCode"]) . and_then (| e | e . get_text () . map (| s | s . to_string ()) . ok_or (savon :: rpser :: xml :: Error :: Empty)) ? , s_name : element . get_at_path (& ["sName"]) . and_then (| e | e . get_text () . map (| s | s . to_string ()) . ok_or (savon :: rpser :: xml :: Error :: Empty)) ? , }) } } # [derive (Clone , Debug , Default)] pub struct ListOfCountryNamesGroupedByContinentResponse { pub list_of_country_names_grouped_by_continent_result : ArrayOftCountryCodeAndNameGroupedByContinent , } impl savon :: gen :: ToElements for ListOfCountryNamesGroupedByContinentResponse { fn to_elements (& self) -> Vec < xmltree :: Element > { vec ! [vec ! [xmltree :: Element :: node ("ListOfCountryNamesGroupedByContinentResult") . with_children (self . list_of_country_names_grouped_by_continent_result . to_elements ())]] . drain (..) . flatten () . collect () } } impl savon :: gen :: FromElement for ListOfCountryNamesGroupedByContinentResponse { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { Ok (ListOfCountryNamesGroupedByContinentResponse { list_of_country_names_grouped_by_continent_result : element . get_at_path (& ["ListOfCountryNamesGroupedByContinentResult"]) . map_err (savon :: Error :: from) . and_then (| e | ArrayOftCountryCodeAndNameGroupedByContinent :: from_element (& e) . map_err (savon :: Error :: from)) ? , }) } } # [derive (Clone , Debug , Default)] pub struct CountryIntPhoneCode { pub s_country_i_s_o_code : String , } impl savon :: gen :: ToElements for CountryIntPhoneCode { fn to_elements (& self) -> Vec < xmltree :: Element > { vec ! [vec ! [xmltree :: Element :: node ("sCountryISOCode") . with_text (self . s_country_i_s_o_code . to_string ())]] . drain (..) . flatten () . collect () } } impl savon :: gen :: FromElement for CountryIntPhoneCode { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { Ok (CountryIntPhoneCode { s_country_i_s_o_code : element . get_at_path (& ["sCountryISOCode"]) . and_then (| e | e . get_text () . map (| s | s . to_string ()) . ok_or (savon :: rpser :: xml :: Error :: Empty)) ? , }) } } # [derive (Clone , Debug , Default)] pub struct ListOfCountryNamesByCodeResponse { pub list_of_country_names_by_code_result : ArrayOftCountryCodeAndName , } impl savon :: gen :: ToElements for ListOfCountryNamesByCodeResponse { fn to_elements (& self) -> Vec < xmltree :: Element > { vec ! [vec ! [xmltree :: Element :: node ("ListOfCountryNamesByCodeResult") . with_children (self . list_of_country_names_by_code_result . to_elements ())]] . drain (..) . flatten () . collect () } } impl savon :: gen :: FromElement for ListOfCountryNamesByCodeResponse { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { Ok (ListOfCountryNamesByCodeResponse { list_of_country_names_by_code_result : element . get_at_path (& ["ListOfCountryNamesByCodeResult"]) . map_err (savon :: Error :: from) . and_then (| e | ArrayOftCountryCodeAndName :: from_element (& e) . map_err (savon :: Error :: from)) ? , }) } } # [derive (Clone , Debug , Default)] pub struct ArrayOftContinent { pub t_continent : Option < Vec < TContinent > > , } impl savon :: gen :: ToElements for ArrayOftContinent { fn to_elements (& self) -> Vec < xmltree :: Element > { vec ! [self . t_continent . as_ref () . map (| v | v . iter () . map (| i | { xmltree :: Element :: node ("tContinent") . with_children (i . to_elements ()) }) . collect ()) . unwrap_or_else (Vec :: new)] . drain (..) . flatten () . collect () } } impl savon :: gen :: FromElement for ArrayOftContinent { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { Ok (ArrayOftContinent { t_continent : Some ({ let mut v = vec ! [] ; for elem in element . children . iter () . filter_map (| c | c . as_element ()) { v . push (TContinent :: from_element (& elem) ?) ; } v } ,) }) } } # [derive (Clone , Debug , Default)] pub struct ArrayOftLanguage { pub t_language : Option < Vec < TLanguage > > , } impl savon :: gen :: ToElements for ArrayOftLanguage { fn to_elements (& self) -> Vec < xmltree :: Element > { vec ! [self . t_language . as_ref () . map (| v | v . iter () . map (| i | { xmltree :: Element :: node ("tLanguage") . with_children (i . to_elements ()) }) . collect ()) . unwrap_or_else (Vec :: new)] . drain (..) . flatten () . collect () } } impl savon :: gen :: FromElement for ArrayOftLanguage { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { Ok (ArrayOftLanguage { t_language : Some ({ let mut v = vec ! [] ; for elem in element . children . iter () . filter_map (| c | c . as_element ()) { v . push (TLanguage :: from_element (& elem) ?) ; } v } ,) }) } } # [derive (Clone , Debug , Default)] pub struct ListOfCountryNamesByName { } impl savon :: gen :: ToElements for ListOfCountryNamesByName { fn to_elements (& self) -> Vec < xmltree :: Element > { vec ! [] } } impl savon :: gen :: FromElement for ListOfCountryNamesByName { fn from_element (_element : & xmltree :: Element) -> Result < Self , savon :: Error > { Ok (ListOfCountryNamesByName { }) } } # [derive (Clone , Debug , Default)] pub struct CountryCurrency { pub s_country_i_s_o_code : String , } impl savon :: gen :: ToElements for CountryCurrency { fn to_elements (& self) -> Vec < xmltree :: Element > { vec ! [vec ! [xmltree :: Element :: node ("sCountryISOCode") . with_text (self . s_country_i_s_o_code . to_string ())]] . drain (..) . flatten () . collect () } } impl savon :: gen :: FromElement for CountryCurrency { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { Ok (CountryCurrency { s_country_i_s_o_code : element . get_at_path (& ["sCountryISOCode"]) . and_then (| e | e . get_text () . map (| s | s . to_string ()) . ok_or (savon :: rpser :: xml :: Error :: Empty)) ? , }) } } # [derive (Clone , Debug , Default)] pub struct ListOfLanguagesByNameResponse { pub list_of_languages_by_name_result : ArrayOftLanguage , } impl savon :: gen :: ToElements for ListOfLanguagesByNameResponse { fn to_elements (& self) -> Vec < xmltree :: Element > { vec ! [vec ! [xmltree :: Element :: node ("ListOfLanguagesByNameResult") . with_children (self . list_of_languages_by_name_result . to_elements ())]] . drain (..) . flatten () . collect () } } impl savon :: gen :: FromElement for ListOfLanguagesByNameResponse { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { Ok (ListOfLanguagesByNameResponse { list_of_languages_by_name_result : element . get_at_path (& ["ListOfLanguagesByNameResult"]) . map_err (savon :: Error :: from) . and_then (| e | ArrayOftLanguage :: from_element (& e) . map_err (savon :: Error :: from)) ? , }) } } # [derive (Clone , Debug , Default)] pub struct CapitalCityResponse { pub capital_city_result : String , } impl savon :: gen :: ToElements for CapitalCityResponse { fn to_elements (& self) -> Vec < xmltree :: Element > { vec ! [vec ! [xmltree :: Element :: node ("CapitalCityResult") . with_text (self . capital_city_result . to_string ())]] . drain (..) . flatten () . collect () } } impl savon :: gen :: FromElement for CapitalCityResponse { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { Ok (CapitalCityResponse { capital_city_result : element . get_at_path (& ["CapitalCityResult"]) . and_then (| e | e . get_text () . map (| s | s . to_string ()) . ok_or (savon :: rpser :: xml :: Error :: Empty)) ? , }) } } # [derive (Clone , Debug , Default)] pub struct ArrayOftCountryInfo { pub t_country_info : Option < Vec < TCountryInfo > > , } impl savon :: gen :: ToElements for ArrayOftCountryInfo { fn to_elements (& self) -> Vec < xmltree :: Element > { vec ! [self . t_country_info . as_ref () . map (| v | v . iter () . map (| i | { xmltree :: Element :: node ("tCountryInfo") . with_children (i . to_elements ()) }) . collect ()) . unwrap_or_else (Vec :: new)] . drain (..) . flatten () . collect () } } impl savon :: gen :: FromElement for ArrayOftCountryInfo { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { Ok (ArrayOftCountryInfo { t_country_info : Some ({ let mut v = vec ! [] ; for elem in element . children . iter () . filter_map (| c | c . as_element ()) { v . push (TCountryInfo :: from_element (& elem) ?) ; } v } ,) }) } } # [derive (Clone , Debug , Default)] pub struct ListOfCountryNamesByCode { } impl savon :: gen :: ToElements for ListOfCountryNamesByCode { fn to_elements (& self) -> Vec < xmltree :: Element > { vec ! [] } } impl savon :: gen :: FromElement for ListOfCountryNamesByCode { fn from_element (_element : & xmltree :: Element) -> Result < Self , savon :: Error > { Ok (ListOfCountryNamesByCode { }) } } # [derive (Clone , Debug , Default)] pub struct CountryCurrencyResponse { pub country_currency_result : TCurrency , } impl savon :: gen :: ToElements for CountryCurrencyResponse { fn to_elements (& self) -> Vec < xmltree :: Element > { vec ! [vec ! [xmltree :: Element :: node ("CountryCurrencyResult") . with_children (self . country_currency_result . to_elements ())]] . drain (..) . flatten () . collect () } } impl savon :: gen :: FromElement for CountryCurrencyResponse { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { Ok (CountryCurrencyResponse { country_currency_result : element . get_at_path (& ["CountryCurrencyResult"]) . map_err (savon :: Error :: from) . and_then (| e | TCurrency :: from_element (& e) . map_err (savon :: Error :: from)) ? , }) } } # [derive (Clone , Debug , Default)] pub struct FullCountryInfo { pub s_country_i_s_o_code : String , } impl savon :: gen :: ToElements for FullCountryInfo { fn to_elements (& self) -> Vec < xmltree :: Element > { vec ! [vec ! [xmltree :: Element :: node ("sCountryISOCode") . with_text (self . s_country_i_s_o_code . to_string ())]] . drain (..) . flatten () . collect () } } impl savon :: gen :: FromElement for FullCountryInfo { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { Ok (FullCountryInfo { s_country_i_s_o_code : element . get_at_path (& ["sCountryISOCode"]) . and_then (| e | e . get_text () . map (| s | s . to_string ()) . ok_or (savon :: rpser :: xml :: Error :: Empty)) ? , }) } } # [derive (Clone , Debug , Default)] pub struct ArrayOftCurrency { pub t_currency : Option < Vec < TCurrency > > , } impl savon :: gen :: ToElements for ArrayOftCurrency { fn to_elements (& self) -> Vec < xmltree :: Element > { vec ! [self . t_currency . as_ref () . map (| v | v . iter () . map (| i | { xmltree :: Element :: node ("tCurrency") . with_children (i . to_elements ()) }) . collect ()) . unwrap_or_else (Vec :: new)] . drain (..) . flatten () . collect () } } impl savon :: gen :: FromElement for ArrayOftCurrency { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { Ok (ArrayOftCurrency { t_currency : Some ({ let mut v = vec ! [] ; for elem in element . children . iter () . filter_map (| c | c . as_element ()) { v . push (TCurrency :: from_element (& elem) ?) ; } v } ,) }) } } # [derive (Clone , Debug , Default)] pub struct CountriesUsingCurrency { pub s_i_s_o_currency_code : String , } impl savon :: gen :: ToElements for CountriesUsingCurrency { fn to_elements (& self) -> Vec < xmltree :: Element > { vec ! [vec ! [xmltree :: Element :: node ("sISOCurrencyCode") . with_text (self . s_i_s_o_currency_code . to_string ())]] . drain (..) . flatten () . collect () } } impl savon :: gen :: FromElement for CountriesUsingCurrency { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { Ok (CountriesUsingCurrency { s_i_s_o_currency_code : element . get_at_path (& ["sISOCurrencyCode"]) . and_then (| e | e . get_text () . map (| s | s . to_string ()) . ok_or (savon :: rpser :: xml :: Error :: Empty)) ? , }) } } # [derive (Clone , Debug , Default)] pub struct TCountryCodeAndNameGroupedByContinent { pub continent : TContinent , pub country_code_and_names : ArrayOftCountryCodeAndName , } impl savon :: gen :: ToElements for TCountryCodeAndNameGroupedByContinent { fn to_elements (& self) -> Vec < xmltree :: Element > { vec ! [vec ! [xmltree :: Element :: node ("Continent") . with_children (self . continent . to_elements ())] , vec ! [xmltree :: Element :: node ("CountryCodeAndNames") . with_children (self . country_code_and_names . to_elements ())]] . drain (..) . flatten () . collect () } } impl savon :: gen :: FromElement for TCountryCodeAndNameGroupedByContinent { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { Ok (TCountryCodeAndNameGroupedByContinent { continent : element . get_at_path (& ["Continent"]) . map_err (savon :: Error :: from) . and_then (| e | TContinent :: from_element (& e) . map_err (savon :: Error :: from)) ? , country_code_and_names : element . get_at_path (& ["CountryCodeAndNames"]) . map_err (savon :: Error :: from) . and_then (| e | ArrayOftCountryCodeAndName :: from_element (& e) . map_err (savon :: Error :: from)) ? , }) } } # [derive (Clone , Debug , Default)] pub struct TContinent { pub s_name : String , pub s_code : String , } impl savon :: gen :: ToElements for TContinent { fn to_elements (& self) -> Vec < xmltree :: Element > { vec ! [vec ! [xmltree :: Element :: node ("sName") . with_text (self . s_name . to_string ())] , vec ! [xmltree :: Element :: node ("sCode") . with_text (self . s_code . to_string ())]] . drain (..) . flatten () . collect () } } impl savon :: gen :: FromElement for TContinent { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { Ok (TContinent { s_name : element . get_at_path (& ["sName"]) . and_then (| e | e . get_text () . map (| s | s . to_string ()) . ok_or (savon :: rpser :: xml :: Error :: Empty)) ? , s_code : element . get_at_path (& ["sCode"]) . and_then (| e | e . get_text () . map (| s | s . to_string ()) . ok_or (savon :: rpser :: xml :: Error :: Empty)) ? , }) } } # [derive (Clone , Debug , Default)] pub struct ListOfCurrenciesByName { } impl savon :: gen :: ToElements for ListOfCurrenciesByName { fn to_elements (& self) -> Vec < xmltree :: Element > { vec ! [] } } impl savon :: gen :: FromElement for ListOfCurrenciesByName { fn from_element (_element : & xmltree :: Element) -> Result < Self , savon :: Error > { Ok (ListOfCurrenciesByName { }) } } # [derive (Clone , Debug , Default)] pub struct CountryFlagResponse { pub country_flag_result : String , } impl savon :: gen :: ToElements for CountryFlagResponse { fn to_elements (& self) -> Vec < xmltree :: Element > { vec ! [vec ! [xmltree :: Element :: node ("CountryFlagResult") . with_text (self . country_flag_result . to_string ())]] . drain (..) . flatten () . collect () } } impl savon :: gen :: FromElement for CountryFlagResponse { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { Ok (CountryFlagResponse { country_flag_result : element . get_at_path (& ["CountryFlagResult"]) . and_then (| e | e . get_text () . map (| s | s . to_string ()) . ok_or (savon :: rpser :: xml :: Error :: Empty)) ? , }) } } # [derive (Clone , Debug , Default)] pub struct ListOfLanguagesByCode { } impl savon :: gen :: ToElements for ListOfLanguagesByCode { fn to_elements (& self) -> Vec < xmltree :: Element > { vec ! [] } } impl savon :: gen :: FromElement for ListOfLanguagesByCode { fn from_element (_element : & xmltree :: Element) -> Result < Self , savon :: Error > { Ok (ListOfLanguagesByCode { }) } } # [derive (Clone , Debug , Default)] pub struct CountryNameResponse { pub country_name_result : String , } impl savon :: gen :: ToElements for CountryNameResponse { fn to_elements (& self) -> Vec < xmltree :: Element > { vec ! [vec ! [xmltree :: Element :: node ("CountryNameResult") . with_text (self . country_name_result . to_string ())]] . drain (..) . flatten () . collect () } } impl savon :: gen :: FromElement for CountryNameResponse { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { Ok (CountryNameResponse { country_name_result : element . get_at_path (& ["CountryNameResult"]) . and_then (| e | e . get_text () . map (| s | s . to_string ()) . ok_or (savon :: rpser :: xml :: Error :: Empty)) ? , }) } } # [derive (Clone , Debug , Default)] pub struct ListOfLanguagesByCodeResponse { pub list_of_languages_by_code_result : ArrayOftLanguage , } impl savon :: gen :: ToElements for ListOfLanguagesByCodeResponse { fn to_elements (& self) -> Vec < xmltree :: Element > { vec ! [vec ! [xmltree :: Element :: node ("ListOfLanguagesByCodeResult") . with_children (self . list_of_languages_by_code_result . to_elements ())]] . drain (..) . flatten () . collect () } } impl savon :: gen :: FromElement for ListOfLanguagesByCodeResponse { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { Ok (ListOfLanguagesByCodeResponse { list_of_languages_by_code_result : element . get_at_path (& ["ListOfLanguagesByCodeResult"]) . map_err (savon :: Error :: from) . and_then (| e | ArrayOftLanguage :: from_element (& e) . map_err (savon :: Error :: from)) ? , }) } } # [derive (Clone , Debug , Default)] pub struct CountryISOCodeResponse { pub country_i_s_o_code_result : String , } impl savon :: gen :: ToElements for CountryISOCodeResponse { fn to_elements (& self) -> Vec < xmltree :: Element > { vec ! [vec ! [xmltree :: Element :: node ("CountryISOCodeResult") . with_text (self . country_i_s_o_code_result . to_string ())]] . drain (..) . flatten () . collect () } } impl savon :: gen :: FromElement for CountryISOCodeResponse { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { Ok (CountryISOCodeResponse { country_i_s_o_code_result : element . get_at_path (& ["CountryISOCodeResult"]) . and_then (| e | e . get_text () . map (| s | s . to_string ()) . ok_or (savon :: rpser :: xml :: Error :: Empty)) ? , }) } } # [derive (Clone , Debug , Default)] pub struct CountryIntPhoneCodeResponse { pub country_int_phone_code_result : String , } impl savon :: gen :: ToElements for CountryIntPhoneCodeResponse { fn to_elements (& self) -> Vec < xmltree :: Element > { vec ! [vec ! [xmltree :: Element :: node ("CountryIntPhoneCodeResult") . with_text (self . country_int_phone_code_result . to_string ())]] . drain (..) . flatten () . collect () } } impl savon :: gen :: FromElement for CountryIntPhoneCodeResponse { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { Ok (CountryIntPhoneCodeResponse { country_int_phone_code_result : element . get_at_path (& ["CountryIntPhoneCodeResult"]) . and_then (| e | e . get_text () . map (| s | s . to_string ()) . ok_or (savon :: rpser :: xml :: Error :: Empty)) ? , }) } } # [derive (Clone , Debug , Default)] pub struct ListOfContinentsByCode { } impl savon :: gen :: ToElements for ListOfContinentsByCode { fn to_elements (& self) -> Vec < xmltree :: Element > { vec ! [] } } impl savon :: gen :: FromElement for ListOfContinentsByCode { fn from_element (_element : & xmltree :: Element) -> Result < Self , savon :: Error > { Ok (ListOfContinentsByCode { }) } } # [derive (Clone , Debug , Default)] pub struct CountriesUsingCurrencyResponse { pub countries_using_currency_result : ArrayOftCountryCodeAndName , } impl savon :: gen :: ToElements for CountriesUsingCurrencyResponse { fn to_elements (& self) -> Vec < xmltree :: Element > { vec ! [vec ! [xmltree :: Element :: node ("CountriesUsingCurrencyResult") . with_children (self . countries_using_currency_result . to_elements ())]] . drain (..) . flatten () . collect () } } impl savon :: gen :: FromElement for CountriesUsingCurrencyResponse { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { Ok (CountriesUsingCurrencyResponse { countries_using_currency_result : element . get_at_path (& ["CountriesUsingCurrencyResult"]) . map_err (savon :: Error :: from) . and_then (| e | ArrayOftCountryCodeAndName :: from_element (& e) . map_err (savon :: Error :: from)) ? , }) } } # [derive (Clone , Debug , Default)] pub struct ListOfCountryNamesByNameResponse { pub list_of_country_names_by_name_result : ArrayOftCountryCodeAndName , } impl savon :: gen :: ToElements for ListOfCountryNamesByNameResponse { fn to_elements (& self) -> Vec < xmltree :: Element > { vec ! [vec ! [xmltree :: Element :: node ("ListOfCountryNamesByNameResult") . with_children (self . list_of_country_names_by_name_result . to_elements ())]] . drain (..) . flatten () . collect () } } impl savon :: gen :: FromElement for ListOfCountryNamesByNameResponse { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { Ok (ListOfCountryNamesByNameResponse { list_of_country_names_by_name_result : element . get_at_path (& ["ListOfCountryNamesByNameResult"]) . map_err (savon :: Error :: from) . and_then (| e | ArrayOftCountryCodeAndName :: from_element (& e) . map_err (savon :: Error :: from)) ? , }) } } # [derive (Clone , Debug , Default)] pub struct LanguageNameResponse { pub language_name_result : String , } impl savon :: gen :: ToElements for LanguageNameResponse { fn to_elements (& self) -> Vec < xmltree :: Element > { vec ! [vec ! [xmltree :: Element :: node ("LanguageNameResult") . with_text (self . language_name_result . to_string ())]] . drain (..) . flatten () . collect () } } impl savon :: gen :: FromElement for LanguageNameResponse { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { Ok (LanguageNameResponse { language_name_result : element . get_at_path (& ["LanguageNameResult"]) . and_then (| e | e . get_text () . map (| s | s . to_string ()) . ok_or (savon :: rpser :: xml :: Error :: Empty)) ? , }) } } # [derive (Clone , Debug , Default)] pub struct CountryFlag { pub s_country_i_s_o_code : String , } impl savon :: gen :: ToElements for CountryFlag { fn to_elements (& self) -> Vec < xmltree :: Element > { vec ! [vec ! [xmltree :: Element :: node ("sCountryISOCode") . with_text (self . s_country_i_s_o_code . to_string ())]] . drain (..) . flatten () . collect () } } impl savon :: gen :: FromElement for CountryFlag { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { Ok (CountryFlag { s_country_i_s_o_code : element . get_at_path (& ["sCountryISOCode"]) . and_then (| e | e . get_text () . map (| s | s . to_string ()) . ok_or (savon :: rpser :: xml :: Error :: Empty)) ? , }) } } # [derive (Clone , Debug , Default)] pub struct CurrencyNameResponse { pub currency_name_result : String , } impl savon :: gen :: ToElements for CurrencyNameResponse { fn to_elements (& self) -> Vec < xmltree :: Element > { vec ! [vec ! [xmltree :: Element :: node ("CurrencyNameResult") . with_text (self . currency_name_result . to_string ())]] . drain (..) . flatten () . collect () } } impl savon :: gen :: FromElement for CurrencyNameResponse { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { Ok (CurrencyNameResponse { currency_name_result : element . get_at_path (& ["CurrencyNameResult"]) . and_then (| e | e . get_text () . map (| s | s . to_string ()) . ok_or (savon :: rpser :: xml :: Error :: Empty)) ? , }) } } # [derive (Clone , Debug , Default)] pub struct FullCountryInfoResponse { pub full_country_info_result : TCountryInfo , } impl savon :: gen :: ToElements for FullCountryInfoResponse { fn to_elements (& self) -> Vec < xmltree :: Element > { vec ! [vec ! [xmltree :: Element :: node ("FullCountryInfoResult") . with_children (self . full_country_info_result . to_elements ())]] . drain (..) . flatten () . collect () } } impl savon :: gen :: FromElement for FullCountryInfoResponse { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { Ok (FullCountryInfoResponse { full_country_info_result : element . get_at_path (& ["FullCountryInfoResult"]) . map_err (savon :: Error :: from) . and_then (| e | TCountryInfo :: from_element (& e) . map_err (savon :: Error :: from)) ? , }) } } # [derive (Clone , Debug , Default)] pub struct LanguageISOCode { pub s_language_name : String , } impl savon :: gen :: ToElements for LanguageISOCode { fn to_elements (& self) -> Vec < xmltree :: Element > { vec ! [vec ! [xmltree :: Element :: node ("sLanguageName") . with_text (self . s_language_name . to_string ())]] . drain (..) . flatten () . collect () } } impl savon :: gen :: FromElement for LanguageISOCode { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { Ok (LanguageISOCode { s_language_name : element . get_at_path (& ["sLanguageName"]) . and_then (| e | e . get_text () . map (| s | s . to_string ()) . ok_or (savon :: rpser :: xml :: Error :: Empty)) ? , }) } } # [derive (Clone , Debug , Default)] pub struct CurrencyName { pub s_currency_i_s_o_code : String , } impl savon :: gen :: ToElements for CurrencyName { fn to_elements (& self) -> Vec < xmltree :: Element > { vec ! [vec ! [xmltree :: Element :: node ("sCurrencyISOCode") . with_text (self . s_currency_i_s_o_code . to_string ())]] . drain (..) . flatten () . collect () } } impl savon :: gen :: FromElement for CurrencyName { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { Ok (CurrencyName { s_currency_i_s_o_code : element . get_at_path (& ["sCurrencyISOCode"]) . and_then (| e | e . get_text () . map (| s | s . to_string ()) . ok_or (savon :: rpser :: xml :: Error :: Empty)) ? , }) } } # [derive (Clone , Debug , Default)] pub struct ArrayOftCountryCodeAndNameGroupedByContinent { pub t_country_code_and_name_grouped_by_continent : Option < Vec < TCountryCodeAndNameGroupedByContinent > > , } impl savon :: gen :: ToElements for ArrayOftCountryCodeAndNameGroupedByContinent { fn to_elements (& self) -> Vec < xmltree :: Element > { vec ! [self . t_country_code_and_name_grouped_by_continent . as_ref () . map (| v | v . iter () . map (| i | { xmltree :: Element :: node ("tCountryCodeAndNameGroupedByContinent") . with_children (i . to_elements ()) }) . collect ()) . unwrap_or_else (Vec :: new)] . drain (..) . flatten () . collect () } } impl savon :: gen :: FromElement for ArrayOftCountryCodeAndNameGroupedByContinent { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { Ok (ArrayOftCountryCodeAndNameGroupedByContinent { t_country_code_and_name_grouped_by_continent : Some ({ let mut v = vec ! [] ; for elem in element . children . iter () . filter_map (| c | c . as_element ()) { v . push (TCountryCodeAndNameGroupedByContinent :: from_element (& elem) ?) ; } v } ,) }) } } # [derive (Clone , Debug , Default)] pub struct ListOfContinentsByNameResponse { pub list_of_continents_by_name_result : ArrayOftContinent , } impl savon :: gen :: ToElements for ListOfContinentsByNameResponse { fn to_elements (& self) -> Vec < xmltree :: Element > { vec ! [vec ! [xmltree :: Element :: node ("ListOfContinentsByNameResult") . with_children (self . list_of_continents_by_name_result . to_elements ())]] . drain (..) . flatten () . collect () } } impl savon :: gen :: FromElement for ListOfContinentsByNameResponse { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { Ok (ListOfContinentsByNameResponse { list_of_continents_by_name_result : element . get_at_path (& ["ListOfContinentsByNameResult"]) . map_err (savon :: Error :: from) . and_then (| e | ArrayOftContinent :: from_element (& e) . map_err (savon :: Error :: from)) ? , }) } } # [derive (Clone , Debug , Default)] pub struct CapitalCity { pub s_country_i_s_o_code : String , } impl savon :: gen :: ToElements for CapitalCity { fn to_elements (& self) -> Vec < xmltree :: Element > { vec ! [vec ! [xmltree :: Element :: node ("sCountryISOCode") . with_text (self . s_country_i_s_o_code . to_string ())]] . drain (..) . flatten () . collect () } } impl savon :: gen :: FromElement for CapitalCity { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { Ok (CapitalCity { s_country_i_s_o_code : element . get_at_path (& ["sCountryISOCode"]) . and_then (| e | e . get_text () . map (| s | s . to_string ()) . ok_or (savon :: rpser :: xml :: Error :: Empty)) ? , }) } } # [derive (Clone , Debug , Default)] pub struct ListOfCountryNamesGroupedByContinent { } impl savon :: gen :: ToElements for ListOfCountryNamesGroupedByContinent { fn to_elements (& self) -> Vec < xmltree :: Element > { vec ! [] } } impl savon :: gen :: FromElement for ListOfCountryNamesGroupedByContinent { fn from_element (_element : & xmltree :: Element) -> Result < Self , savon :: Error > { Ok (ListOfCountryNamesGroupedByContinent { }) } } # [derive (Clone , Debug , Default)] pub struct ListOfContinentsByCodeResponse { pub list_of_continents_by_code_result : ArrayOftContinent , } impl savon :: gen :: ToElements for ListOfContinentsByCodeResponse { fn to_elements (& self) -> Vec < xmltree :: Element > { vec ! [vec ! [xmltree :: Element :: node ("ListOfContinentsByCodeResult") . with_children (self . list_of_continents_by_code_result . to_elements ())]] . drain (..) . flatten () . collect () } } impl savon :: gen :: FromElement for ListOfContinentsByCodeResponse { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { Ok (ListOfContinentsByCodeResponse { list_of_continents_by_code_result : element . get_at_path (& ["ListOfContinentsByCodeResult"]) . map_err (savon :: Error :: from) . and_then (| e | ArrayOftContinent :: from_element (& e) . map_err (savon :: Error :: from)) ? , }) } } # [derive (Clone , Debug , Default)] pub struct ListOfCurrenciesByCode { } impl savon :: gen :: ToElements for ListOfCurrenciesByCode { fn to_elements (& self) -> Vec < xmltree :: Element > { vec ! [] } } impl savon :: gen :: FromElement for ListOfCurrenciesByCode { fn from_element (_element : & xmltree :: Element) -> Result < Self , savon :: Error > { Ok (ListOfCurrenciesByCode { }) } } pub struct CountryInfoService { pub base_url : String , pub client : savon :: internal :: reqwest :: Client , } # [derive (Clone , Debug , Default)] pub struct LanguageNameSoapRequest (pub LanguageName) ; impl savon :: gen :: ToElements for LanguageNameSoapRequest { fn to_elements (& self) -> Vec < xmltree :: Element > { self . 0 . to_elements () } } impl savon :: gen :: FromElement for LanguageNameSoapRequest { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { LanguageName :: from_element (element) . map (LanguageNameSoapRequest) } } # [derive (Clone , Debug , Default)] pub struct ListOfCurrenciesByCodeSoapRequest (pub ListOfCurrenciesByCode) ; impl savon :: gen :: ToElements for ListOfCurrenciesByCodeSoapRequest { fn to_elements (& self) -> Vec < xmltree :: Element > { self . 0 . to_elements () } } impl savon :: gen :: FromElement for ListOfCurrenciesByCodeSoapRequest { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { ListOfCurrenciesByCode :: from_element (element) . map (ListOfCurrenciesByCodeSoapRequest) } } # [derive (Clone , Debug , Default)] pub struct CountriesUsingCurrencySoapRequest (pub CountriesUsingCurrency) ; impl savon :: gen :: ToElements for CountriesUsingCurrencySoapRequest { fn to_elements (& self) -> Vec < xmltree :: Element > { self . 0 . to_elements () } } impl savon :: gen :: FromElement for CountriesUsingCurrencySoapRequest { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { CountriesUsingCurrency :: from_element (element) . map (CountriesUsingCurrencySoapRequest) } } # [derive (Clone , Debug , Default)] pub struct ListOfCountryNamesGroupedByContinentSoapResponse (pub ListOfCountryNamesGroupedByContinentResponse) ; impl savon :: gen :: ToElements for ListOfCountryNamesGroupedByContinentSoapResponse { fn to_elements (& self) -> Vec < xmltree :: Element > { self . 0 . to_elements () } } impl savon :: gen :: FromElement for ListOfCountryNamesGroupedByContinentSoapResponse { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { ListOfCountryNamesGroupedByContinentResponse :: from_element (element) . map (ListOfCountryNamesGroupedByContinentSoapResponse) } } # [derive (Clone , Debug , Default)] pub struct ListOfContinentsByNameSoapRequest (pub ListOfContinentsByName) ; impl savon :: gen :: ToElements for ListOfContinentsByNameSoapRequest { fn to_elements (& self) -> Vec < xmltree :: Element > { self . 0 . to_elements () } } impl savon :: gen :: FromElement for ListOfContinentsByNameSoapRequest { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { ListOfContinentsByName :: from_element (element) . map (ListOfContinentsByNameSoapRequest) } } # [derive (Clone , Debug , Default)] pub struct LanguageISOCodeSoapResponse (pub LanguageISOCodeResponse) ; impl savon :: gen :: ToElements for LanguageISOCodeSoapResponse { fn to_elements (& self) -> Vec < xmltree :: Element > { self . 0 . to_elements () } } impl savon :: gen :: FromElement for LanguageISOCodeSoapResponse { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { LanguageISOCodeResponse :: from_element (element) . map (LanguageISOCodeSoapResponse) } } # [derive (Clone , Debug , Default)] pub struct ListOfContinentsByCodeSoapRequest (pub ListOfContinentsByCode) ; impl savon :: gen :: ToElements for ListOfContinentsByCodeSoapRequest { fn to_elements (& self) -> Vec < xmltree :: Element > { self . 0 . to_elements () } } impl savon :: gen :: FromElement for ListOfContinentsByCodeSoapRequest { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { ListOfContinentsByCode :: from_element (element) . map (ListOfContinentsByCodeSoapRequest) } } # [derive (Clone , Debug , Default)] pub struct CountryNameSoapRequest (pub CountryName) ; impl savon :: gen :: ToElements for CountryNameSoapRequest { fn to_elements (& self) -> Vec < xmltree :: Element > { self . 0 . to_elements () } } impl savon :: gen :: FromElement for CountryNameSoapRequest { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { CountryName :: from_element (element) . map (CountryNameSoapRequest) } } # [derive (Clone , Debug , Default)] pub struct CountryFlagSoapResponse (pub CountryFlagResponse) ; impl savon :: gen :: ToElements for CountryFlagSoapResponse { fn to_elements (& self) -> Vec < xmltree :: Element > { self . 0 . to_elements () } } impl savon :: gen :: FromElement for CountryFlagSoapResponse { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { CountryFlagResponse :: from_element (element) . map (CountryFlagSoapResponse) } } # [derive (Clone , Debug , Default)] pub struct FullCountryInfoSoapResponse (pub FullCountryInfoResponse) ; impl savon :: gen :: ToElements for FullCountryInfoSoapResponse { fn to_elements (& self) -> Vec < xmltree :: Element > { self . 0 . to_elements () } } impl savon :: gen :: FromElement for FullCountryInfoSoapResponse { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { FullCountryInfoResponse :: from_element (element) . map (FullCountryInfoSoapResponse) } } # [derive (Clone , Debug , Default)] pub struct FullCountryInfoSoapRequest (pub FullCountryInfo) ; impl savon :: gen :: ToElements for FullCountryInfoSoapRequest { fn to_elements (& self) -> Vec < xmltree :: Element > { self . 0 . to_elements () } } impl savon :: gen :: FromElement for FullCountryInfoSoapRequest { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { FullCountryInfo :: from_element (element) . map (FullCountryInfoSoapRequest) } } # [derive (Clone , Debug , Default)] pub struct LanguageISOCodeSoapRequest (pub LanguageISOCode) ; impl savon :: gen :: ToElements for LanguageISOCodeSoapRequest { fn to_elements (& self) -> Vec < xmltree :: Element > { self . 0 . to_elements () } } impl savon :: gen :: FromElement for LanguageISOCodeSoapRequest { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { LanguageISOCode :: from_element (element) . map (LanguageISOCodeSoapRequest) } } # [derive (Clone , Debug , Default)] pub struct CurrencyNameSoapRequest (pub CurrencyName) ; impl savon :: gen :: ToElements for CurrencyNameSoapRequest { fn to_elements (& self) -> Vec < xmltree :: Element > { self . 0 . to_elements () } } impl savon :: gen :: FromElement for CurrencyNameSoapRequest { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { CurrencyName :: from_element (element) . map (CurrencyNameSoapRequest) } } # [derive (Clone , Debug , Default)] pub struct ListOfLanguagesByNameSoapRequest (pub ListOfLanguagesByName) ; impl savon :: gen :: ToElements for ListOfLanguagesByNameSoapRequest { fn to_elements (& self) -> Vec < xmltree :: Element > { self . 0 . to_elements () } } impl savon :: gen :: FromElement for ListOfLanguagesByNameSoapRequest { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { ListOfLanguagesByName :: from_element (element) . map (ListOfLanguagesByNameSoapRequest) } } # [derive (Clone , Debug , Default)] pub struct CapitalCitySoapResponse (pub CapitalCityResponse) ; impl savon :: gen :: ToElements for CapitalCitySoapResponse { fn to_elements (& self) -> Vec < xmltree :: Element > { self . 0 . to_elements () } } impl savon :: gen :: FromElement for CapitalCitySoapResponse { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { CapitalCityResponse :: from_element (element) . map (CapitalCitySoapResponse) } } # [derive (Clone , Debug , Default)] pub struct ListOfLanguagesByNameSoapResponse (pub ListOfLanguagesByNameResponse) ; impl savon :: gen :: ToElements for ListOfLanguagesByNameSoapResponse { fn to_elements (& self) -> Vec < xmltree :: Element > { self . 0 . to_elements () } } impl savon :: gen :: FromElement for ListOfLanguagesByNameSoapResponse { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { ListOfLanguagesByNameResponse :: from_element (element) . map (ListOfLanguagesByNameSoapResponse) } } # [derive (Clone , Debug , Default)] pub struct ListOfLanguagesByCodeSoapRequest (pub ListOfLanguagesByCode) ; impl savon :: gen :: ToElements for ListOfLanguagesByCodeSoapRequest { fn to_elements (& self) -> Vec < xmltree :: Element > { self . 0 . to_elements () } } impl savon :: gen :: FromElement for ListOfLanguagesByCodeSoapRequest { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { ListOfLanguagesByCode :: from_element (element) . map (ListOfLanguagesByCodeSoapRequest) } } # [derive (Clone , Debug , Default)] pub struct ListOfCountryNamesByCodeSoapRequest (pub ListOfCountryNamesByCode) ; impl savon :: gen :: ToElements for ListOfCountryNamesByCodeSoapRequest { fn to_elements (& self) -> Vec < xmltree :: Element > { self . 0 . to_elements () } } impl savon :: gen :: FromElement for ListOfCountryNamesByCodeSoapRequest { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { ListOfCountryNamesByCode :: from_element (element) . map (ListOfCountryNamesByCodeSoapRequest) } } # [derive (Clone , Debug , Default)] pub struct CountryCurrencySoapResponse (pub CountryCurrencyResponse) ; impl savon :: gen :: ToElements for CountryCurrencySoapResponse { fn to_elements (& self) -> Vec < xmltree :: Element > { self . 0 . to_elements () } } impl savon :: gen :: FromElement for CountryCurrencySoapResponse { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { CountryCurrencyResponse :: from_element (element) . map (CountryCurrencySoapResponse) } } # [derive (Clone , Debug , Default)] pub struct CountryISOCodeSoapResponse (pub CountryISOCodeResponse) ; impl savon :: gen :: ToElements for CountryISOCodeSoapResponse { fn to_elements (& self) -> Vec < xmltree :: Element > { self . 0 . to_elements () } } impl savon :: gen :: FromElement for CountryISOCodeSoapResponse { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { CountryISOCodeResponse :: from_element (element) . map (CountryISOCodeSoapResponse) } } # [derive (Clone , Debug , Default)] pub struct ListOfCurrenciesByCodeSoapResponse (pub ListOfCurrenciesByCodeResponse) ; impl savon :: gen :: ToElements for ListOfCurrenciesByCodeSoapResponse { fn to_elements (& self) -> Vec < xmltree :: Element > { self . 0 . to_elements () } } impl savon :: gen :: FromElement for ListOfCurrenciesByCodeSoapResponse { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { ListOfCurrenciesByCodeResponse :: from_element (element) . map (ListOfCurrenciesByCodeSoapResponse) } } # [derive (Clone , Debug , Default)] pub struct ListOfCurrenciesByNameSoapRequest (pub ListOfCurrenciesByName) ; impl savon :: gen :: ToElements for ListOfCurrenciesByNameSoapRequest { fn to_elements (& self) -> Vec < xmltree :: Element > { self . 0 . to_elements () } } impl savon :: gen :: FromElement for ListOfCurrenciesByNameSoapRequest { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { ListOfCurrenciesByName :: from_element (element) . map (ListOfCurrenciesByNameSoapRequest) } } # [derive (Clone , Debug , Default)] pub struct CountryCurrencySoapRequest (pub CountryCurrency) ; impl savon :: gen :: ToElements for CountryCurrencySoapRequest { fn to_elements (& self) -> Vec < xmltree :: Element > { self . 0 . to_elements () } } impl savon :: gen :: FromElement for CountryCurrencySoapRequest { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { CountryCurrency :: from_element (element) . map (CountryCurrencySoapRequest) } } # [derive (Clone , Debug , Default)] pub struct ListOfCountryNamesByNameSoapResponse (pub ListOfCountryNamesByNameResponse) ; impl savon :: gen :: ToElements for ListOfCountryNamesByNameSoapResponse { fn to_elements (& self) -> Vec < xmltree :: Element > { self . 0 . to_elements () } } impl savon :: gen :: FromElement for ListOfCountryNamesByNameSoapResponse { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { ListOfCountryNamesByNameResponse :: from_element (element) . map (ListOfCountryNamesByNameSoapResponse) } } # [derive (Clone , Debug , Default)] pub struct CapitalCitySoapRequest (pub CapitalCity) ; impl savon :: gen :: ToElements for CapitalCitySoapRequest { fn to_elements (& self) -> Vec < xmltree :: Element > { self . 0 . to_elements () } } impl savon :: gen :: FromElement for CapitalCitySoapRequest { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { CapitalCity :: from_element (element) . map (CapitalCitySoapRequest) } } # [derive (Clone , Debug , Default)] pub struct ListOfContinentsByNameSoapResponse (pub ListOfContinentsByNameResponse) ; impl savon :: gen :: ToElements for ListOfContinentsByNameSoapResponse { fn to_elements (& self) -> Vec < xmltree :: Element > { self . 0 . to_elements () } } impl savon :: gen :: FromElement for ListOfContinentsByNameSoapResponse { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { ListOfContinentsByNameResponse :: from_element (element) . map (ListOfContinentsByNameSoapResponse) } } # [derive (Clone , Debug , Default)] pub struct ListOfCountryNamesGroupedByContinentSoapRequest (pub ListOfCountryNamesGroupedByContinent) ; impl savon :: gen :: ToElements for ListOfCountryNamesGroupedByContinentSoapRequest { fn to_elements (& self) -> Vec < xmltree :: Element > { self . 0 . to_elements () } } impl savon :: gen :: FromElement for ListOfCountryNamesGroupedByContinentSoapRequest { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { ListOfCountryNamesGroupedByContinent :: from_element (element) . map (ListOfCountryNamesGroupedByContinentSoapRequest) } } # [derive (Clone , Debug , Default)] pub struct ListOfCountryNamesByNameSoapRequest (pub ListOfCountryNamesByName) ; impl savon :: gen :: ToElements for ListOfCountryNamesByNameSoapRequest { fn to_elements (& self) -> Vec < xmltree :: Element > { self . 0 . to_elements () } } impl savon :: gen :: FromElement for ListOfCountryNamesByNameSoapRequest { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { ListOfCountryNamesByName :: from_element (element) . map (ListOfCountryNamesByNameSoapRequest) } } # [derive (Clone , Debug , Default)] pub struct CountryIntPhoneCodeSoapRequest (pub CountryIntPhoneCode) ; impl savon :: gen :: ToElements for CountryIntPhoneCodeSoapRequest { fn to_elements (& self) -> Vec < xmltree :: Element > { self . 0 . to_elements () } } impl savon :: gen :: FromElement for CountryIntPhoneCodeSoapRequest { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { CountryIntPhoneCode :: from_element (element) . map (CountryIntPhoneCodeSoapRequest) } } # [derive (Clone , Debug , Default)] pub struct ListOfLanguagesByCodeSoapResponse (pub ListOfLanguagesByCodeResponse) ; impl savon :: gen :: ToElements for ListOfLanguagesByCodeSoapResponse { fn to_elements (& self) -> Vec < xmltree :: Element > { self . 0 . to_elements () } } impl savon :: gen :: FromElement for ListOfLanguagesByCodeSoapResponse { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { ListOfLanguagesByCodeResponse :: from_element (element) . map (ListOfLanguagesByCodeSoapResponse) } } # [derive (Clone , Debug , Default)] pub struct LanguageNameSoapResponse (pub LanguageNameResponse) ; impl savon :: gen :: ToElements for LanguageNameSoapResponse { fn to_elements (& self) -> Vec < xmltree :: Element > { self . 0 . to_elements () } } impl savon :: gen :: FromElement for LanguageNameSoapResponse { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { LanguageNameResponse :: from_element (element) . map (LanguageNameSoapResponse) } } # [derive (Clone , Debug , Default)] pub struct ListOfCountryNamesByCodeSoapResponse (pub ListOfCountryNamesByCodeResponse) ; impl savon :: gen :: ToElements for ListOfCountryNamesByCodeSoapResponse { fn to_elements (& self) -> Vec < xmltree :: Element > { self . 0 . to_elements () } } impl savon :: gen :: FromElement for ListOfCountryNamesByCodeSoapResponse { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { ListOfCountryNamesByCodeResponse :: from_element (element) . map (ListOfCountryNamesByCodeSoapResponse) } } # [derive (Clone , Debug , Default)] pub struct CountriesUsingCurrencySoapResponse (pub CountriesUsingCurrencyResponse) ; impl savon :: gen :: ToElements for CountriesUsingCurrencySoapResponse { fn to_elements (& self) -> Vec < xmltree :: Element > { self . 0 . to_elements () } } impl savon :: gen :: FromElement for CountriesUsingCurrencySoapResponse { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { CountriesUsingCurrencyResponse :: from_element (element) . map (CountriesUsingCurrencySoapResponse) } } # [derive (Clone , Debug , Default)] pub struct CountryFlagSoapRequest (pub CountryFlag) ; impl savon :: gen :: ToElements for CountryFlagSoapRequest { fn to_elements (& self) -> Vec < xmltree :: Element > { self . 0 . to_elements () } } impl savon :: gen :: FromElement for CountryFlagSoapRequest { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { CountryFlag :: from_element (element) . map (CountryFlagSoapRequest) } } # [derive (Clone , Debug , Default)] pub struct ListOfContinentsByCodeSoapResponse (pub ListOfContinentsByCodeResponse) ; impl savon :: gen :: ToElements for ListOfContinentsByCodeSoapResponse { fn to_elements (& self) -> Vec < xmltree :: Element > { self . 0 . to_elements () } } impl savon :: gen :: FromElement for ListOfContinentsByCodeSoapResponse { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { ListOfContinentsByCodeResponse :: from_element (element) . map (ListOfContinentsByCodeSoapResponse) } } # [derive (Clone , Debug , Default)] pub struct CountryNameSoapResponse (pub CountryNameResponse) ; impl savon :: gen :: ToElements for CountryNameSoapResponse { fn to_elements (& self) -> Vec < xmltree :: Element > { self . 0 . to_elements () } } impl savon :: gen :: FromElement for CountryNameSoapResponse { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { CountryNameResponse :: from_element (element) . map (CountryNameSoapResponse) } } # [derive (Clone , Debug , Default)] pub struct CountryISOCodeSoapRequest (pub CountryISOCode) ; impl savon :: gen :: ToElements for CountryISOCodeSoapRequest { fn to_elements (& self) -> Vec < xmltree :: Element > { self . 0 . to_elements () } } impl savon :: gen :: FromElement for CountryISOCodeSoapRequest { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { CountryISOCode :: from_element (element) . map (CountryISOCodeSoapRequest) } } # [derive (Clone , Debug , Default)] pub struct FullCountryInfoAllCountriesSoapResponse (pub FullCountryInfoAllCountriesResponse) ; impl savon :: gen :: ToElements for FullCountryInfoAllCountriesSoapResponse { fn to_elements (& self) -> Vec < xmltree :: Element > { self . 0 . to_elements () } } impl savon :: gen :: FromElement for FullCountryInfoAllCountriesSoapResponse { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { FullCountryInfoAllCountriesResponse :: from_element (element) . map (FullCountryInfoAllCountriesSoapResponse) } } # [derive (Clone , Debug , Default)] pub struct FullCountryInfoAllCountriesSoapRequest (pub FullCountryInfoAllCountries) ; impl savon :: gen :: ToElements for FullCountryInfoAllCountriesSoapRequest { fn to_elements (& self) -> Vec < xmltree :: Element > { self . 0 . to_elements () } } impl savon :: gen :: FromElement for FullCountryInfoAllCountriesSoapRequest { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { FullCountryInfoAllCountries :: from_element (element) . map (FullCountryInfoAllCountriesSoapRequest) } } # [derive (Clone , Debug , Default)] pub struct ListOfCurrenciesByNameSoapResponse (pub ListOfCurrenciesByNameResponse) ; impl savon :: gen :: ToElements for ListOfCurrenciesByNameSoapResponse { fn to_elements (& self) -> Vec < xmltree :: Element > { self . 0 . to_elements () } } impl savon :: gen :: FromElement for ListOfCurrenciesByNameSoapResponse { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { ListOfCurrenciesByNameResponse :: from_element (element) . map (ListOfCurrenciesByNameSoapResponse) } } # [derive (Clone , Debug , Default)] pub struct CurrencyNameSoapResponse (pub CurrencyNameResponse) ; impl savon :: gen :: ToElements for CurrencyNameSoapResponse { fn to_elements (& self) -> Vec < xmltree :: Element > { self . 0 . to_elements () } } impl savon :: gen :: FromElement for CurrencyNameSoapResponse { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { CurrencyNameResponse :: from_element (element) . map (CurrencyNameSoapResponse) } } # [derive (Clone , Debug , Default)] pub struct CountryIntPhoneCodeSoapResponse (pub CountryIntPhoneCodeResponse) ; impl savon :: gen :: ToElements for CountryIntPhoneCodeSoapResponse { fn to_elements (& self) -> Vec < xmltree :: Element > { self . 0 . to_elements () } } impl savon :: gen :: FromElement for CountryIntPhoneCodeSoapResponse { fn from_element (element : & xmltree :: Element) -> Result < Self , savon :: Error > { CountryIntPhoneCodeResponse :: from_element (element) . map (CountryIntPhoneCodeSoapResponse) } } # [allow (dead_code)] impl CountryInfoService { pub fn new (base_url : String) -> Self { Self :: with_client (base_url , savon :: internal :: reqwest :: Client :: new ()) } pub fn with_client (base_url : String , client : savon :: internal :: reqwest :: Client) -> Self { CountryInfoService { base_url , client , } } pub async fn country_name (& self , country_name_soap_request : CountryNameSoapRequest) -> Result < Result < CountryNameSoapResponse , () > , savon :: Error > { savon :: http :: request_response (& self . client , & self . base_url , "http://www.oorsprong.org/websamples.countryinfo" , "CountryName" , & country_name_soap_request) . await } pub async fn language_name (& self , language_name_soap_request : LanguageNameSoapRequest) -> Result < Result < LanguageNameSoapResponse , () > , savon :: Error > { savon :: http :: request_response (& self . client , & self . base_url , "http://www.oorsprong.org/websamples.countryinfo" , "LanguageName" , & language_name_soap_request) . await } pub async fn full_country_info_all_countries (& self , full_country_info_all_countries_soap_request : FullCountryInfoAllCountriesSoapRequest) -> Result < Result < FullCountryInfoAllCountriesSoapResponse , () > , savon :: Error > { savon :: http :: request_response (& self . client , & self . base_url , "http://www.oorsprong.org/websamples.countryinfo" , "FullCountryInfoAllCountries" , & full_country_info_all_countries_soap_request) . await } pub async fn capital_city (& self , capital_city_soap_request : CapitalCitySoapRequest) -> Result < Result < CapitalCitySoapResponse , () > , savon :: Error > { savon :: http :: request_response (& self . client , & self . base_url , "http://www.oorsprong.org/websamples.countryinfo" , "CapitalCity" , & capital_city_soap_request) . await } pub async fn list_of_country_names_by_code (& self , list_of_country_names_by_code_soap_request : ListOfCountryNamesByCodeSoapRequest) -> Result < Result < ListOfCountryNamesByCodeSoapResponse , () > , savon :: Error > { savon :: http :: request_response (& self . client , & self . base_url , "http://www.oorsprong.org/websamples.countryinfo" , "ListOfCountryNamesByCode" , & list_of_country_names_by_code_soap_request) . await } pub async fn full_country_info (& self , full_country_info_soap_request : FullCountryInfoSoapRequest) -> Result < Result < FullCountryInfoSoapResponse , () > , savon :: Error > { savon :: http :: request_response (& self . client , & self . base_url , "http://www.oorsprong.org/websamples.countryinfo" , "FullCountryInfo" , & full_country_info_soap_request) . await } pub async fn list_of_continents_by_name (& self , list_of_continents_by_name_soap_request : ListOfContinentsByNameSoapRequest) -> Result < Result < ListOfContinentsByNameSoapResponse , () > , savon :: Error > { savon :: http :: request_response (& self . client , & self . base_url , "http://www.oorsprong.org/websamples.countryinfo" , "ListOfContinentsByName" , & list_of_continents_by_name_soap_request) . await } pub async fn country_i_s_o_code (& self , country_i_s_o_code_soap_request : CountryISOCodeSoapRequest) -> Result < Result < CountryISOCodeSoapResponse , () > , savon :: Error > { savon :: http :: request_response (& self . client , & self . base_url , "http://www.oorsprong.org/websamples.countryinfo" , "CountryISOCode" , & country_i_s_o_code_soap_request) . await } pub async fn list_of_country_names_grouped_by_continent (& self , list_of_country_names_grouped_by_continent_soap_request : ListOfCountryNamesGroupedByContinentSoapRequest) -> Result < Result < ListOfCountryNamesGroupedByContinentSoapResponse , () > , savon :: Error > { savon :: http :: request_response (& self . client , & self . base_url , "http://www.oorsprong.org/websamples.countryinfo" , "ListOfCountryNamesGroupedByContinent" , & list_of_country_names_grouped_by_continent_soap_request) . await } pub async fn list_of_languages_by_code (& self , list_of_languages_by_code_soap_request : ListOfLanguagesByCodeSoapRequest) -> Result < Result < ListOfLanguagesByCodeSoapResponse , () > , savon :: Error > { savon :: http :: request_response (& self . client , & self . base_url , "http://www.oorsprong.org/websamples.countryinfo" , "ListOfLanguagesByCode" , & list_of_languages_by_code_soap_request) . await } pub async fn language_i_s_o_code (& self , language_i_s_o_code_soap_request : LanguageISOCodeSoapRequest) -> Result < Result < LanguageISOCodeSoapResponse , () > , savon :: Error > { savon :: http :: request_response (& self . client , & self . base_url , "http://www.oorsprong.org/websamples.countryinfo" , "LanguageISOCode" , & language_i_s_o_code_soap_request) . await } pub async fn currency_name (& self , currency_name_soap_request : CurrencyNameSoapRequest) -> Result < Result < CurrencyNameSoapResponse , () > , savon :: Error > { savon :: http :: request_response (& self . client , & self . base_url , "http://www.oorsprong.org/websamples.countryinfo" , "CurrencyName" , & currency_name_soap_request) . await } pub async fn list_of_currencies_by_name (& self , list_of_currencies_by_name_soap_request : ListOfCurrenciesByNameSoapRequest) -> Result < Result < ListOfCurrenciesByNameSoapResponse , () > , savon :: Error > { savon :: http :: request_response (& self . client , & self . base_url , "http://www.oorsprong.org/websamples.countryinfo" , "ListOfCurrenciesByName" , & list_of_currencies_by_name_soap_request) . await } pub async fn countries_using_currency (& self , countries_using_currency_soap_request : CountriesUsingCurrencySoapRequest) -> Result < Result < CountriesUsingCurrencySoapResponse , () > , savon :: Error > { savon :: http :: request_response (& self . client , & self . base_url , "http://www.oorsprong.org/websamples.countryinfo" , "CountriesUsingCurrency" , & countries_using_currency_soap_request) . await } pub async fn list_of_continents_by_code (& self , list_of_continents_by_code_soap_request : ListOfContinentsByCodeSoapRequest) -> Result < Result < ListOfContinentsByCodeSoapResponse , () > , savon :: Error > { savon :: http :: request_response (& self . client , & self . base_url , "http://www.oorsprong.org/websamples.countryinfo" , "ListOfContinentsByCode" , & list_of_continents_by_code_soap_request) . await } pub async fn list_of_languages_by_name (& self , list_of_languages_by_name_soap_request : ListOfLanguagesByNameSoapRequest) -> Result < Result < ListOfLanguagesByNameSoapResponse , () > , savon :: Error > { savon :: http :: request_response (& self . client , & self . base_url , "http://www.oorsprong.org/websamples.countryinfo" , "ListOfLanguagesByName" , & list_of_languages_by_name_soap_request) . await } pub async fn country_int_phone_code (& self , country_int_phone_code_soap_request : CountryIntPhoneCodeSoapRequest) -> Result < Result < CountryIntPhoneCodeSoapResponse , () > , savon :: Error > { savon :: http :: request_response (& self . client , & self . base_url , "http://www.oorsprong.org/websamples.countryinfo" , "CountryIntPhoneCode" , & country_int_phone_code_soap_request) . await } pub async fn country_currency (& self , country_currency_soap_request : CountryCurrencySoapRequest) -> Result < Result < CountryCurrencySoapResponse , () > , savon :: Error > { savon :: http :: request_response (& self . client , & self . base_url , "http://www.oorsprong.org/websamples.countryinfo" , "CountryCurrency" , & country_currency_soap_request) . await } pub async fn list_of_country_names_by_name (& self , list_of_country_names_by_name_soap_request : ListOfCountryNamesByNameSoapRequest) -> Result < Result < ListOfCountryNamesByNameSoapResponse , () > , savon :: Error > { savon :: http :: request_response (& self . client , & self . base_url , "http://www.oorsprong.org/websamples.countryinfo" , "ListOfCountryNamesByName" , & list_of_country_names_by_name_soap_request) . await } pub async fn country_flag (& self , country_flag_soap_request : CountryFlagSoapRequest) -> Result < Result < CountryFlagSoapResponse , () > , savon :: Error > { savon :: http :: request_response (& self . client , & self . base_url , "http://www.oorsprong.org/websamples.countryinfo" , "CountryFlag" , & country_flag_soap_request) . await } pub async fn list_of_currencies_by_code (& self , list_of_currencies_by_code_soap_request : ListOfCurrenciesByCodeSoapRequest) -> Result < Result < ListOfCurrenciesByCodeSoapResponse , () > , savon :: Error > { savon :: http :: request_response (& self . client , & self . base_url , "http://www.oorsprong.org/websamples.countryinfo" , "ListOfCurrenciesByCode" , & list_of_currencies_by_code_soap_request) . await } }